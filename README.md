# quadruple
Taken from CodePlex, code by Jeff Pasternack:
https://quadruple.codeplex.com/
Ryan!
Signed 128-bit floating point data type library, with 64 effective bits of precision (vs. 53 for Doubles) and a 64 bit exponent (vs. 11 for Doubles). Quads have greater precision and far greater range than Doubles and are especially useful when dealing with very large or very small values, such as those in probabilistic models. As of version 2.0, all Quad arithmetic is checked (underflowing to 0, overflowing to +/- infinity), has special PositiveInfinity, NegativeInfinity, and NaN values, and follows the same rules as .Net Double arithmetic and comparison operators (e.g. 1/0 == PositiveInfinity, 0 * PositiveInfinity == NaN, NaN != NaN), making it a convenient drop-in replacement for Doubles in existing code.

Adopting a larger fixed precision rather than an arbitrary precision type (such as Java's BigDecimal) means that, while still slower than built-in arithmetic, the penalty is only an order of magnitude or less and thus still feasible in many math-heavy applications. For example, on an Intel Core i5-2410M laptop, 10 billion multiplications take 17 seconds with Double values, 163 seconds with Quad values using the overloaded * operator, 134 seconds with the Multiply() method (faster than * due to the poor inlining logic of the .Net compiler/JIT optimizer), and just 105 seconds with the MultiplyUnchecked() method which assumes no underflow or overflow. By comparison, the commonly-used workaround for multiplication underflow and overflow, summing logarithms, takes 140 seconds. In addition to being faster and more precise than log arithmetic, Quads also simplify code by eliminating the need to remember which variables are log'd and converting back and forth to log'd values. Version 1.0 of the library is even faster (up to ~25%) and is still available, but lacks the underflow and overflow detection of v.2.0; future revisions to v.2.0 should narrow the performance gap as branch misprediction is reduced by reordering code.